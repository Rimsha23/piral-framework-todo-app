"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPilet = exports.buildPiletDefaults = void 0;
const path_1 = require("path");
const types_1 = require("../types");
const bundler_1 = require("../bundler");
const common_1 = require("../common");
function createMetadata(outDir, outFile, pilets, publicPath) {
    return (0, common_1.writeJson)(outDir, outFile, pilets.map((p) => ({
        name: p.package.name,
        version: p.package.version,
        link: `${publicPath}${p.id}/${p.outFile}`,
        ...(0, common_1.getPiletSpecMeta)(p.path, `${publicPath}${p.id}/`),
    })));
}
function copyPilets(outDir, pilets) {
    return Promise.all(pilets.map(async (p) => {
        const files = await (0, common_1.getFileNames)(p.outDir);
        for (const file of files) {
            await (0, common_1.copy)((0, path_1.resolve)(p.outDir, file), (0, path_1.resolve)(outDir, p.id, file), common_1.ForceOverwrite.yes);
        }
    }));
}
exports.buildPiletDefaults = {
    entry: './src/index',
    target: './dist/index.js',
    publicUrl: '/',
    minify: true,
    logLevel: types_1.LogLevels.info,
    type: 'default',
    fresh: false,
    sourceMaps: true,
    watch: false,
    contentHash: true,
    optimizeModules: false,
    schemaVersion: undefined,
    concurrency: common_1.cpuCount,
    declaration: true,
};
async function buildPilet(baseDir = process.cwd(), options = {}) {
    const { entry = exports.buildPiletDefaults.entry, target = exports.buildPiletDefaults.target, publicUrl: originalPublicUrl = exports.buildPiletDefaults.publicUrl, logLevel = exports.buildPiletDefaults.logLevel, minify = exports.buildPiletDefaults.minify, sourceMaps = exports.buildPiletDefaults.sourceMaps, watch = exports.buildPiletDefaults.watch, contentHash = exports.buildPiletDefaults.contentHash, fresh = exports.buildPiletDefaults.fresh, concurrency = exports.buildPiletDefaults.concurrency, optimizeModules = exports.buildPiletDefaults.optimizeModules, schemaVersion: originalSchemaVersion = exports.buildPiletDefaults.schemaVersion, declaration = exports.buildPiletDefaults.declaration, type = exports.buildPiletDefaults.type, _ = {}, hooks = {}, bundlerName, app, } = options;
    const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
    const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
    const entryList = Array.isArray(entry) ? entry : [entry];
    (0, common_1.setLogLevel)(logLevel);
    await hooks.onBegin?.({ options, fullBase });
    (0, common_1.progress)('Reading configuration ...');
    const allEntries = await (0, common_1.matchAnyPilet)(fullBase, entryList);
    (0, common_1.log)('generalDebug_0003', `Found the following entries: ${allEntries.join(', ')}`);
    if (allEntries.length === 0) {
        (0, common_1.fail)('entryFileMissing_0077');
    }
    const pilets = await (0, common_1.concurrentWorkers)(allEntries, concurrency, async (entryModule) => {
        const targetDir = (0, path_1.dirname)(entryModule);
        const { peerDependencies, peerModules, root, apps, piletPackage, ignored, importmap, schema } = await (0, common_1.retrievePiletData)(targetDir, app);
        const schemaVersion = originalSchemaVersion || schema || common_1.config.schemaVersion || common_1.defaultSchemaVersion;
        const piralInstances = apps.map((m) => m.appPackage.name);
        const externals = (0, common_1.combinePiletExternals)(piralInstances, peerDependencies, peerModules, importmap);
        const dest = (0, path_1.resolve)(root, target);
        const outDir = (0, path_1.dirname)(dest);
        const outFile = (0, path_1.basename)(dest);
        (0, common_1.validateSharedDependencies)(importmap);
        if (fresh) {
            (0, common_1.progress)('Removing output directory ...');
            await (0, common_1.removeDirectory)(outDir);
        }
        (0, common_1.logInfo)('Bundle pilet ...');
        await hooks.beforeBuild?.({ root, outDir, importmap, entryModule, schemaVersion, piletPackage });
        await (0, bundler_1.callPiletBuild)({
            root,
            piralInstances,
            optimizeModules,
            sourceMaps,
            watch,
            contentHash,
            minify,
            externals,
            targetDir,
            importmap,
            outFile,
            outDir,
            entryModule: `./${(0, path_1.relative)(root, entryModule)}`,
            logLevel,
            version: schemaVersion,
            ignored,
            _,
        }, bundlerName);
        await hooks.afterBuild?.({ root, outDir, importmap, entryModule, schemaVersion, piletPackage });
        if (declaration) {
            await hooks.beforeDeclaration?.({ root, outDir, entryModule, piletPackage });
            await (0, common_1.createPiletDeclaration)(piletPackage.name, piralInstances, root, entryModule, externals, outDir, common_1.ForceOverwrite.yes, logLevel);
            await hooks.afterDeclaration?.({ root, outDir, entryModule, piletPackage });
        }
        (0, common_1.logDone)(`Pilet "${piletPackage.name}" built successfully!`);
        return {
            id: piletPackage.name.replace(/[^a-zA-Z0-9\-]/gi, ''),
            root,
            apps,
            outDir,
            outFile,
            path: dest,
            package: piletPackage,
        };
    });
    if (type === 'standalone') {
        const distDir = (0, path_1.dirname)((0, path_1.resolve)(fullBase, target));
        const outDir = (0, path_1.resolve)(distDir, 'standalone');
        const { apps, root } = pilets[0];
        if (apps.length === 0) {
            (0, common_1.fail)('appInstancesNotGiven_0012');
        }
        const { appPackage, appFile } = apps[0];
        const piralInstances = [appPackage.name];
        const isEmulator = (0, common_1.checkAppShellPackage)(appPackage);
        (0, common_1.logInfo)('Building standalone solution ...');
        await (0, common_1.removeDirectory)(outDir);
        (0, common_1.progress)('Copying files ...');
        await copyPilets(outDir, pilets);
        await createMetadata(outDir, '$pilet-api', pilets, publicUrl);
        if (isEmulator) {
            // in case of an emulator assets are not "seen" by the bundler, so we
            // just copy overthing over - this should work in most cases.
            await (0, common_1.copy)((0, path_1.dirname)(appFile), outDir, common_1.ForceOverwrite.yes);
            (0, common_1.progress)('Optimizing app shell ...');
            // we don't need to care about externals or other things that are already
            // part of the emulator
            await (0, bundler_1.callPiralBuild)({
                root,
                piralInstances,
                emulator: false,
                standalone: true,
                optimizeModules: false,
                sourceMaps,
                watch: false,
                contentHash,
                minify,
                externals: [],
                publicUrl,
                outFile: 'index.html',
                outDir,
                entryFiles: appFile,
                logLevel,
                ignored: [],
                _,
            }, bundlerName);
        }
        else {
            // in this case we can just do the same steps as if
            const { ignored, externals } = await (0, common_1.retrievePiletsInfo)(appFile);
            await (0, bundler_1.callPiralBuild)({
                root,
                piralInstances,
                emulator: false,
                standalone: true,
                optimizeModules: false,
                sourceMaps,
                watch: false,
                contentHash,
                minify,
                externals: (0, common_1.flattenExternals)(externals),
                publicUrl,
                outFile: 'index.html',
                outDir,
                entryFiles: appFile,
                logLevel,
                ignored,
                _,
            }, bundlerName);
        }
        (0, common_1.logDone)(`Standalone app available at "${outDir}"!`);
    }
    else if (type === 'manifest') {
        const manifest = 'pilets.json';
        const outDir = (0, path_1.dirname)((0, path_1.resolve)(fullBase, target));
        (0, common_1.logInfo)('Building pilet manifest ...');
        (0, common_1.progress)('Copying files ...');
        await copyPilets(outDir, pilets);
        await createMetadata(outDir, manifest, pilets, publicUrl);
        (0, common_1.logDone)(`Manifest available at "${outDir}/${manifest}"!`);
    }
    await hooks.onEnd?.({});
}
exports.buildPilet = buildPilet;
//# sourceMappingURL=build-pilet.js.map