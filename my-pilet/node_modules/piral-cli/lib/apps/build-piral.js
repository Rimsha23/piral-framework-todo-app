"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPiral = exports.buildPiralDefaults = void 0;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
const allName = 'all';
const releaseName = 'release';
const emulatorName = 'emulator';
const emulatorPackageName = 'package';
const emulatorSourcesName = 'sources';
const emulatorWebsiteName = 'website';
exports.buildPiralDefaults = {
    entry: './',
    target: './dist',
    publicUrl: '/',
    logLevel: types_1.LogLevels.info,
    fresh: false,
    minify: true,
    type: allName,
    subdir: true,
    sourceMaps: true,
    watch: false,
    contentHash: true,
    optimizeModules: false,
};
async function runLifecycle(root, scripts, type) {
    const script = scripts?.[type];
    if (script) {
        (0, common_1.log)('generalDebug_0003', `Running "${type}" ("${script}") ...`);
        await (0, common_1.runScript)(script, root);
        (0, common_1.log)('generalDebug_0003', `Finished running "${type}".`);
    }
    else {
        (0, common_1.log)('generalDebug_0003', `No script for "${type}" found ...`);
    }
}
async function buildPiral(baseDir = process.cwd(), options = {}) {
    const { entry = exports.buildPiralDefaults.entry, target = exports.buildPiralDefaults.target, publicUrl: originalPublicUrl = exports.buildPiralDefaults.publicUrl, logLevel = exports.buildPiralDefaults.logLevel, minify = exports.buildPiralDefaults.minify, sourceMaps = exports.buildPiralDefaults.sourceMaps, watch = exports.buildPiralDefaults.watch, contentHash = exports.buildPiralDefaults.contentHash, subdir = exports.buildPiralDefaults.subdir, fresh = exports.buildPiralDefaults.fresh, type = exports.buildPiralDefaults.type, optimizeModules = exports.buildPiralDefaults.optimizeModules, _ = {}, hooks = {}, bundlerName, } = options;
    const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
    const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
    const useSubdir = type === 'all' || subdir;
    (0, common_1.setLogLevel)(logLevel);
    await hooks.onBegin?.({ options, fullBase });
    (0, common_1.progress)('Reading configuration ...');
    const entryFiles = await (0, common_1.retrievePiralRoot)(fullBase, entry);
    const { name, root, ignored, externals, scripts, emulator = emulatorPackageName, } = await (0, common_1.retrievePiletsInfo)(entryFiles);
    const piralInstances = [name];
    const dest = (0, common_1.getDestination)(entryFiles, (0, path_1.resolve)(fullBase, target));
    await (0, common_1.checkCliCompatibility)(root);
    (0, common_1.validateSharedDependencies)(externals);
    if (fresh) {
        (0, common_1.progress)('Removing output directory ...');
        await (0, common_1.removeDirectory)(dest.outDir);
    }
    // either take the explicit type or find out the implicit / default one
    const emulatorType = type === allName || type === emulatorName ? emulator : type.replace(`${emulatorName}-`, '');
    // only applies to an explicit emulator target (e.g., "emulator-website") or to "all" / "emulator" with the setting from the piral.json
    if ([emulatorSourcesName, emulatorPackageName, emulatorWebsiteName].includes(emulatorType)) {
        const emulatorPublicUrl = '/';
        const targetDir = useSubdir ? (0, path_1.join)(dest.outDir, emulatorName) : dest.outDir;
        const appDir = emulatorType !== emulatorWebsiteName ? (0, path_1.join)(targetDir, 'app') : targetDir;
        (0, common_1.progress)('Starting emulator build ...');
        // since we create this anyway let's just pretend we want to have it clean!
        await (0, common_1.removeDirectory)(targetDir);
        await hooks.beforeBuild?.({ root, publicUrl: emulatorPublicUrl, externals, entryFiles, targetDir, piralInstances });
        (0, common_1.logInfo)(`Bundle ${emulatorName} ...`);
        const { dir: outDir, name: outFile, hash, } = await (0, bundler_1.callPiralBuild)({
            root,
            piralInstances,
            emulator: true,
            standalone: false,
            optimizeModules,
            sourceMaps,
            watch,
            contentHash,
            minify: false,
            externals: (0, common_1.flattenExternals)(externals),
            publicUrl: emulatorPublicUrl,
            entryFiles,
            logLevel,
            ignored,
            outDir: appDir,
            outFile: dest.outFile,
            _,
        }, bundlerName);
        await hooks.afterBuild?.({
            root,
            publicUrl: emulatorPublicUrl,
            externals,
            entryFiles,
            targetDir,
            piralInstances,
            hash,
            outDir,
            outFile,
        });
        await runLifecycle(root, scripts, 'piral:postbuild');
        await runLifecycle(root, scripts, `piral:postbuild-${emulatorName}`);
        await hooks.beforeEmulator?.({ root, externals, targetDir, outDir });
        let rootDir = root;
        switch (emulatorType) {
            case emulatorPackageName:
                rootDir = await (0, common_1.createEmulatorSources)(root, externals, outDir, outFile, logLevel);
                await hooks.beforePackage?.({ root, externals, targetDir, outDir, rootDir });
                await (0, common_1.packageEmulator)(rootDir);
                await hooks.afterPackage?.({ root, externals, targetDir, outDir, rootDir });
                break;
            case emulatorSourcesName:
                rootDir = await (0, common_1.createEmulatorSources)(root, externals, outDir, outFile, logLevel);
                (0, common_1.logDone)(`Emulator package sources available in "${rootDir}".`);
                break;
            case emulatorWebsiteName:
                rootDir = await (0, common_1.createEmulatorWebsite)(root, externals, outDir, outFile, logLevel);
                (0, common_1.logDone)(`Emulator website available in "${rootDir}".`);
                break;
        }
        await hooks.afterEmulator?.({ root, externals, targetDir, outDir, rootDir });
        (0, common_1.logReset)();
    }
    // either 'release' or 'all'
    if (type === releaseName || type === allName) {
        const targetDir = useSubdir ? (0, path_1.join)(dest.outDir, releaseName) : dest.outDir;
        (0, common_1.progress)('Starting release build ...');
        // since we create this anyway let's just pretend we want to have it clean!
        await (0, common_1.removeDirectory)(targetDir);
        (0, common_1.logInfo)(`Bundle ${releaseName} ...`);
        await hooks.beforeBuild?.({ root, publicUrl, externals, entryFiles, targetDir, piralInstances });
        const { dir: outDir, name: outFile, hash, } = await (0, bundler_1.callPiralBuild)({
            root,
            piralInstances,
            emulator: false,
            standalone: false,
            optimizeModules,
            sourceMaps,
            watch,
            contentHash,
            minify,
            externals: (0, common_1.flattenExternals)(externals),
            publicUrl,
            outFile: dest.outFile,
            outDir: targetDir,
            entryFiles,
            logLevel,
            ignored,
            _,
        }, bundlerName);
        await hooks.afterBuild?.({
            root,
            publicUrl,
            externals,
            entryFiles,
            targetDir,
            piralInstances,
            outDir,
            outFile,
            hash,
        });
        await runLifecycle(root, scripts, 'piral:postbuild');
        await runLifecycle(root, scripts, `piral:postbuild-${releaseName}`);
        (0, common_1.logDone)(`Files for publication available in "${outDir}".`);
        (0, common_1.logReset)();
    }
    await hooks.onEnd?.({ root });
}
exports.buildPiral = buildPiral;
//# sourceMappingURL=build-piral.js.map