"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderElement = void 0;
const components_1 = require("../components");
const utils_1 = require("../utils");
if (typeof window !== 'undefined' && 'customElements' in window) {
    const contents = 'contents';
    /**
     * This is a nice abstraction allowing anyone to actually use the extension system
     * brought by Piral. Not all props of the extension system are actually exposed.
     *
     * Usage:
     *
     * ```
     * <piral-extension name="my-ext-name"></piral-extension>
     * ```
     */
    class PiralExtension extends HTMLElement {
        constructor() {
            super(...arguments);
            this.dispose = utils_1.noop;
            this.update = utils_1.noop;
            this.props = {
                name: this.getAttribute('name'),
                emptySkipsRender: typeof this.getAttribute('empty-skips-render') === 'string',
                params: (0, utils_1.tryParseJson)(this.getAttribute('params')),
                empty: undefined,
                order: undefined,
                render: undefined,
                children: (0, utils_1.reactifyContent)(this.childNodes),
            };
        }
        get params() {
            return this.props.params;
        }
        set params(value) {
            if (!(0, utils_1.isSame)(this.props.params, value)) {
                this.props.params = value;
                this.update(this.props);
            }
        }
        get name() {
            return this.props.name;
        }
        set name(value) {
            if (this.props.name !== value) {
                this.props.name = value;
                this.update(this.props);
            }
        }
        get order() {
            return this.props.order;
        }
        set order(value) {
            if (this.props.order !== value) {
                this.props.order = value;
                this.update(this.props);
            }
        }
        get render() {
            return this.props.render;
        }
        set render(value) {
            if (this.props.render !== value) {
                this.props.render = value;
                this.update(this.props);
            }
        }
        get empty() {
            return this.props.empty;
        }
        set empty(value) {
            if (this.props.empty !== value) {
                this.props.empty = value;
                this.update(this.props);
            }
        }
        get emptySkipsRender() {
            return this.props.emptySkipsRender;
        }
        set emptySkipsRender(value) {
            if (this.props.emptySkipsRender !== value) {
                this.props.emptySkipsRender = value;
                this.update(this.props);
            }
        }
        connectedCallback() {
            this.style.display = contents;
            if (this.isConnected) {
                this.dispatchEvent(new CustomEvent('render-html', {
                    bubbles: true,
                    composed: true,
                    detail: {
                        target: this,
                        props: this.props,
                    },
                }));
            }
        }
        disconnectedCallback() {
            this.dispose();
            this.dispose = utils_1.noop;
            this.update = utils_1.noop;
        }
        attributeChangedCallback(name, _, newValue) {
            switch (name) {
                case 'name':
                    this.name = newValue;
                    break;
                case 'params':
                    this.params = (0, utils_1.tryParseJson)(newValue);
                    break;
                case 'empty-skips-render':
                    this.emptySkipsRender = typeof newValue === 'string';
                    break;
            }
        }
        static get observedAttributes() {
            return ['name', 'params', 'empty-skips-render'];
        }
    }
    customElements.define(utils_1.extensionName, PiralExtension);
    /**
     * This is a boundary to host elements from other frameworks - effectively vanishing
     * at runtime.
     *
     * Usage:
     *
     * ```
     * <piral-portal pid="host-1234"></piral-portal>
     * ```
     */
    class PiralPortal extends HTMLElement {
        connectedCallback() {
            this.style.display = contents;
        }
    }
    customElements.define(utils_1.portalName, PiralPortal);
    /**
     * This is a virtual element to aggregate rendering from other frameworks, mostly
     * used like piral-portal, but without context-hosting capabilities. This would
     * be used exclusively within a foreign framework, not from Piral to initiate.
     *
     * Usage:
     *
     * ```
     * <piral-slot></piral-slot>
     * ```
     */
    class PiralSlot extends HTMLElement {
        connectedCallback() {
            this.style.display = contents;
        }
    }
    customElements.define(utils_1.slotName, PiralSlot);
    /**
     * This is a virtual element to render children defined in React / by Piral in other
     * frameworks.
     *
     * Internally, you can use the assignContent function to populate the content to be
     * rendered once the element is attached / mounted in the DOM.
     *
     * Usage:
     *
     * ```
     * <piral-content cid="123"></piral-content>
     * ```
     *
     * where you'd
     *
     * ```
     * window.assignContent("123", myReactContent)
     * ```
     *
     * beforehand.
     */
    class PiralContent extends HTMLElement {
        constructor() {
            super(...arguments);
            this.dispose = utils_1.noop;
        }
        connectedCallback() {
            this.style.display = contents;
            const cid = this.getAttribute('cid');
            const content = PiralContent.contentAssignments[cid];
            const portal = this.closest('piral-portal');
            if (content && portal) {
                const portalId = portal.getAttribute('pid');
                window.dispatchEvent(new CustomEvent('render-content', {
                    detail: { target: this, content, portalId },
                }));
            }
        }
        disconnectedCallback() {
            this.dispose();
            this.dispose = utils_1.noop;
        }
    }
    PiralContent.contentAssignments = {};
    window.assignContent = (cid, content) => {
        PiralContent.contentAssignments[cid] = content;
    };
    customElements.define(utils_1.contentName, PiralContent);
    /**
     * This is a virtual element to indicate that the contained content is
     * rendered from a micro frontend's component. It will be used by the
     * orchestrator, so there is nothing you will need to do with it.
     *
     * Right now this is only used when you opt-in in the createInstance.
     */
    class PiralComponent extends HTMLElement {
        get name() {
            return this.getAttribute('name');
        }
        get origin() {
            return this.getAttribute('origin');
        }
        connectedCallback() {
            this.style.display = contents;
            this.deferEvent('add-component');
        }
        disconnectedCallback() {
            this.deferEvent('remove-component');
        }
        deferEvent(eventName) {
            const ev = new CustomEvent(eventName, {
                detail: { name: this.name, origin: this.origin },
            });
            setTimeout(() => window.dispatchEvent(ev), 0);
        }
    }
    customElements.define(utils_1.componentName, PiralComponent);
}
function renderElement(context, element, props) {
    if (typeof window !== 'undefined') {
        let [id, portal] = (0, utils_1.renderInDom)(context, element, components_1.ExtensionSlot, props);
        const evName = 'extension-props-changed';
        const handler = (ev) => update(ev.detail);
        const dispose = () => {
            context.hidePortal(id, portal);
            element.removeEventListener(evName, handler);
        };
        const update = (newProps) => {
            [id, portal] = (0, utils_1.changeDomPortal)(id, portal, context, element, components_1.ExtensionSlot, newProps);
        };
        element.addEventListener(evName, handler);
        return [dispose, update];
    }
    return [utils_1.noop, utils_1.noop];
}
exports.renderElement = renderElement;
//# sourceMappingURL=element.js.map